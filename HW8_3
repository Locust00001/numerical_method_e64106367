#include <stdio.h>
#include <math.h>
#include <stdlib.h> // For exit() if needed, though not used here directly

// Define M_PI if not already defined by math.h (some compilers might not define it by default)
#ifndef M_PI
    #define M_PI 3.14159265358979323846
#endif

// Function f(x) for problem 3: f(x) = x^2 * sin(x)
double func_p3(double x) {
    return x * x * sin(x);
}

int main() {
    printf("\n--- Problem 3: Discrete Least Squares Trigonometric Polynomial S4 ---\n");

    // Given parameters
    int m_val = 16;                  // m = 16
    int num_points_trig = 2 * m_val; // Number of data points = 2m = 32
    double c_interval = 0.0;         // Interval start [c, d] = [0, 1]
    double d_interval = 1.0;         // Interval end

    // Arrays to store data points
    double x_trig[num_points_trig]; // x_j values in [c, d]
    double z_trig[num_points_trig]; // z_j values transformed to [-pi, pi)
    double y_trig[num_points_trig]; // y_j = f(x_j)

    printf("   Generating %d data points for f(x) = x^2*sin(x) on [%.1f, %.1f]...\n",
           num_points_trig, c_interval, d_interval);

    // Generate data points (x_j, y_j) and transform x_j to z_j
    // We sample 2m points in the interval [c,d).
    // x_j = c + j * (d-c) / (2m) for j = 0, ..., 2m-1
    for (int j = 0; j < num_points_trig; j++) {
        x_trig[j] = c_interval + (double)j * (d_interval - c_interval) / (double)num_points_trig;
        y_trig[j] = func_p3(x_trig[j]);
        // Transform x_j in [c,d] to z_j in [-pi, pi)
        // z_j = pi * [2 * (x_j - c) / (d - c) - 1]
        z_trig[j] = M_PI * (2.0 * (x_trig[j] - c_interval) / (d_interval - c_interval) - 1.0);
    }

    // The trigonometric polynomial S4(z) is:
    // S4(z) = a0/2 + a4*cos(4z) + sum_{k=1 to 3} [ak*cos(kz) + bk*sin(kz)]
    // We need coefficients a0, a1, a2, a3, a4 and b1, b2, b3.

    double a_coeffs[5]; // To store a0, a1, a2, a3, a4
    double b_coeffs[4]; // To store b1, b2, b3 (b_coeffs[0] is unused for convenience)

    // --- Calculate Coefficient a0 ---
    // a0 = (1/m) * sum_{j=0 to 2m-1} y_j
    double sum_y_for_a0 = 0.0;
    for (int j = 0; j < num_points_trig; j++) {
        sum_y_for_a0 += y_trig[j];
    }
    a_coeffs[0] = sum_y_for_a0 / (double)m_val;

    // --- Calculate Coefficients ak (for k=1 to 4) ---
    // ak = (1/m) * sum_{j=0 to 2m-1} y_j * cos(k*z_j)
    for (int k = 1; k <= 4; k++) {
        double sum_y_cos_kz = 0.0;
        for (int j = 0; j < num_points_trig; j++) {
            sum_y_cos_kz += y_trig[j] * cos((double)k * z_trig[j]);
        }
        a_coeffs[k] = sum_y_cos_kz / (double)m_val;
    }

    // --- Calculate Coefficients bk (for k=1 to 3) ---
    // bk = (1/m) * sum_{j=0 to 2m-1} y_j * sin(k*z_j)
    // Note: S4 has b_k sin(kz) for k=1 to n-1, where n=4 for S4. So k goes up to 3.
    for (int k = 1; k <= 3; k++) {
        double sum_y_sin_kz = 0.0;
        for (int j = 0; j < num_points_trig; j++) {
            sum_y_sin_kz += y_trig[j] * sin((double)k * z_trig[j]);
        }
        b_coeffs[k] = sum_y_sin_kz / (double)m_val; // Store b1 in b_coeffs[1], b2 in b_coeffs[2], etc.
    }

    printf("\n   Trigonometric polynomial S4 coefficients:\n");
    printf("   a0 = %f\n", a_coeffs[0]);
    for (int k = 1; k <= 4; k++) {
        printf("   a%d = %f\n", k, a_coeffs[k]);
    }
    for (int k = 1; k <= 3; k++) {
        printf("   b%d = %f\n", k, b_coeffs[k]);
    }

    printf("\n   S4(z) = %.6f ", a_coeffs[0] / 2.0);
    for (int k = 1; k <= 3; k++) {
        printf("%+f*cos(%dz) %+f*sin(%dz) ", a_coeffs[k], k, b_coeffs[k], k);
    }
    printf("%+f*cos(4z)\n", a_coeffs[4]);


    // --- Part b: Compute integral of S4(x)dx from 0 to 1 ---
    // Integral S4(x)dx [0,1] = Integral S4(z) (1/(2*pi))dz [-pi,pi]
    // Since integral of cos(kz) and sin(kz) over [-pi,pi] is 0 for k != 0,
    // only the a0/2 term survives: Integral (a0/2) * (1/(2*pi)) dz = (a0/2) * (1/(2*pi)) * 2*pi = a0/2
    double integral_S4_dx = a_coeffs[0] / 2.0;
    printf("\nb. Integral of S4(x)dx from 0 to 1 = a0/2 = %f\n", integral_S4_dx);

    // --- Part c: Compare the integral in part (b) to integral of x^2*sin(x)dx from 0 to 1 ---
    // Indefinite integral of x^2*sin(x)dx is (2-x^2)cos(x) + 2x*sin(x) + C
    // Let F(x) = (2-x^2)cos(x) + 2x*sin(x)
    // Definite integral from 0 to 1 is F(1) - F(0)
    double F_x_sq_sin_x(double x) 
	{
        if (x == 0.0) {
            return (2.0 - 0.0) * cos(0.0) + 2.0 * 0.0 * sin(0.0); // which is 2*1 + 0 = 2
        }
        return (2.0 - x*x) * cos(x) + 2.0 * x * sin(x);
    }
    double true_integral_val = F_x_sq_sin_x(1.0) - F_x_sq_sin_x(0.0);
    printf("\nc. True integral of x^2*sin(x)dx from 0 to 1 = %f\n", true_integral_val);
    printf("   Difference between S4 integral and true integral = %f\n", fabs(integral_S4_dx - true_integral_val));

    // --- Part d: Compute the error E(S4) = sum_{j=0 to 2m-1} [y_j - S4(z_j)]^2 ---
    double error_E_S4 = 0.0;
    for (int j = 0; j < num_points_trig; j++) {
        double s4_val_at_zj = a_coeffs[0] / 2.0; // Start with the constant term
        // Add cosine terms (k=1 to 3 for sum, plus a4cos(4z))
        for (int k = 1; k <= 4; k++) {
            s4_val_at_zj += a_coeffs[k] * cos((double)k * z_trig[j]);
        }
        // Add sine terms (k=1 to 3)
        for (int k = 1; k <= 3; k++) {
            s4_val_at_zj += b_coeffs[k] * sin((double)k * z_trig[j]);
        }
        error_E_S4 += pow(y_trig[j] - s4_val_at_zj, 2);
    }
    printf("\nd. Error E(S4) = sum [y_j - S4(z_j)]^2 = %e\n", error_E_S4);

    return 0; // Indicate successful execution
}
